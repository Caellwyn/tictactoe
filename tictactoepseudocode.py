# -*- coding: utf-8 -*-
"""TicTacToePseudocode.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dSBEc1M6j0MJlMXImowchYJYaaYiaZmL
"""



"""```
training_loop(model, opponent)
    initialize empty board
    flip coin
    if going second
        board = advance play(board, opponent)
    values_for_moves[27] = predict(board)
    chosen_move = best of(values_for_moves)
    board, is legal = play_move(board, chosen_move)
    while game continues
        if is legal
            new_board, game_state = advance_play(board, opponent)
        y = zeros size of values for moves
        if not game over
            new_values_for_moves = predict(new_board)
            new_chosen_move = best of(new_values_for_moves)
        
        for move in value_for_moves
            if move is chosen_move
                if game over or lillegal move
                    y[move] = game result
                else
                    y[move] = max(new_values_for_moves)
            else if move is illegal
                y[move] = -1
            else 
                y[move] = don't care
        backprop(values_for_moves, y)
        if game not over
            value_for_moves = new_value_for moves
            chosen_move = new_chosen_move
            board, is legal = play_move(board, chosen_move)

play_loop(opponent)
    while game isn't over
    flip coin
    initialize board
    if first
        display board
        move = ask player for move
        board = play_move
    while game continues
        new_board, game_state = advance_play(board, opponent)
        if haven't lost
            move = ask player for move
            board = play_move

advance_play(board, opponent)
    move = opponent.get_next_move(board)
    new_board, is legal play_move(board, move)
    if not is legal
        new_board = random_move(board)
    
    return new_board, get_game_state(new_board)

get_game_state(board)

```
"""

def play_move(board, move):
    """
    Applies a supplied move to a supplied board
    
    Arguments:
        board: a np.array of shape (54,1) represent board state before the move is applied.
        move: an integer between 0 and 26 representing an index into `board`

    Returns:
        islegal: a boolean, whether the passed move is legal on the passed board.
        board: the updated board state if the move is legal.  Otherwise, the same board that was passed.
    """
    islegal = True
    if board[move] == 0 and board[move+27] == 0:
        board[move] = 1
    else:
        islegal = False
    return board, islegal

def best_of(moves):

    """
    Returns the index of the highest value in an array, corresponding to the predicted best move.

    Arguments:
    moves: an array of shape (27,1) of floats representing the predicted move values for the board state.
    Returns:
    move: the index of the maximum value of the array.
    """
    import numpy as np
    return np.argmax(moves)

def flip_coin():
    """
    randomly returns a 1 or 0
    """
    import random
    return random.randint(0,1)

import numpy as np
mat = None
def init_wincon_matrix():
  def put():
    mat[x+3*y+9*z, col] = 1
  global mat
  mat = np.zeros((27, 49))
  col = 0

  for x in range(3):
    for y in range(3):
      for z in range(3):
        put()
      col +=1
    for z in range(3):
      for y in range(3):
        put()
      col +=1
    for y in range(3):
      z = y
      put()
    col +=1
    for y in range(3):
      z = 2-y
      put()
    col +=1
  
  for z in range(3):
    for y in range(3):
      for x in range(3):
        put()
      col +=1
    for y in range(3):
      x = y
      put()
    col +=1
    for y in range(3):
      x = 2-y
      put()
    col +=1

  for y in range(3):
    for z in range(3):
      x = z
      put()
    col +=1
    for z in range(3):
      x = 2-z
      put()
    col +=1
  
  for x in range(3):
    y = z = x
    put()
  col +=1

  for x in range(3):
    y = z = 2-x
    put()
  col +=1
  for x in range(3):
    y = x
    z = 2-x
    put()
  col +=1
  for x in range(3):
    z = x
    y = 2-x
    put()
  col +=1
  print(col)




def game_over(board):
  board = board.reshape((1,54))
  if mat is None:
    def init_wincon_matrix():
  if 3 in np.dot(board[:, :27], mat):
    return True, 1
  if 3 in np.dot(board[:, 27:], mat):
    return True, -1
  for i in range(27):
    if not board[i] or board[i+27]:
      break
  else:
    return True, 0
  return False, 0